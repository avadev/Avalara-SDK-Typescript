/* tslint:disable */
/* eslint-disable */
/**
 * foundation
 * Platform foundation consists of services on top of which the Avalara Compliance Cloud platform is built. These services are foundational and provide functionality such as common organization, tenant and user management for the rest of the compliance platform.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import fetch, { Response, RequestInfo, RequestInit } from "node-fetch";
import Logger, { LogOptions } from "./utils/logger";
import LogObject from "./utils/logObject";
export const PRODUCTION_OPENID_CONFIG_URL =
  "https://identity.avalara.com/.well-known/openid-configuration";
export const SANDBOX_OPENID_CONFIG_URL =
  "https://ai-sbx.avlr.sh/.well-known/openid-configuration";
export const QA_OPENID_CONFIG_URL =
  "https://ai-awsfqa.avlr.sh/.well-known/openid-configuration";
export const FALLBACK_TOKEN_URL = "https://identity.avalara.com/connect/token";
export const FALLBACK_DEVICE_AUTHORIZATION_URL =
  "https://identity.avalara.com/connect/deviceauthorization";

/// <summary>
/// Official URL of EInvoicing Service (Production by Environment)
/// </summary>
export const EINVOICING_SERVICE_PRODUCTION_URL = "https://api.avalara.com";
export const EINVOICING_SERVICE_SANDBOX_URL = "https://api.sbx.avalara.com";
export const EINVOICING_SERVICE_QA_URL = "https://superapi.qa.avalara.io";
export const EINVOICING_SERVICE_DEV_URL = "https://superapi.dev.avalara.io";

/// <summary>
/// Official URL of A1099 Service (Production by Environment)
/// </summary>
export const A1099_SERVICE_PRODUCTION_URL = "https://api.avalara.com/avalara1099";
export const A1099_SERVICE_SANDBOX_URL = "https://api.sbx.avalara.com/avalara1099";
export const A1099_SERVICE_QA_URL = "https://api-ava1099.gamma.qa.us-west-2.aws.avalara.io";
export const A1099_SERVICE_DEV_URL = "https://api-ava1099.gamma.dev.us-west-2.aws.avalara.io";

const isBlob = (value: any) =>
  typeof Blob !== "undefined" && value instanceof Blob;

/**
 * This is the base class for all generated API classes.
 */
export class ApiClient {
  private middleware: Middleware[];
  public sdkVersion: string = null;
  private accessTokenMap: Map<string, TokenMetadata> = new Map();
  private logger: Logger;

  constructor(public configuration: Configuration) {
    if (!configuration) {
      throw new Error(
        "Configuration object is a required parameter for ApiClient."
      );
    }
    this.logger = new Logger(configuration.logOptions);
    this.middleware = configuration.middleware || [];
  }

  withMiddleware<T extends ApiClient>(this: T, ...middlewares: Middleware[]) {
    const next = this.clone<T>();
    next.middleware = next.middleware.concat(...middlewares);
    return next;
  }

  withPreMiddleware<T extends ApiClient>(
    this: T,
    ...preMiddlewares: Array<Middleware["pre"]>
  ) {
    const middlewares = preMiddlewares.map((pre) => ({ pre }));
    return this.withMiddleware<T>(...middlewares);
  }

  withPostMiddleware<T extends ApiClient>(
    this: T,
    ...postMiddlewares: Array<Middleware["post"]>
  ) {
    const middlewares = postMiddlewares.map((post) => ({ post }));
    return this.withMiddleware<T>(...middlewares);
  }

  protected async request(
    context: RequestOpts,
    initOverrides?: RequestInit,
    requiredScopes: string = "",
    isRetry: boolean = false,
    microservice: AvalaraMicroservice = AvalaraMicroservice.None
  ): Promise<ResponseWithLogObject> {
    const logObject = new LogObject(this.logger.logRequestAndResponseInfo);
    const { url, init, timeoutId } = this.createFetchParams({
      context,
      logObject,
      initOverrides,
      microservice,
    });
    const { clientId, clientSecret } = this.configuration;

    const response = await this.fetchApi(url, init, logObject);
    const { status } = response;
    clearTimeout(timeoutId);
    if (status >= 200 && status < 300) {
      return { response, logObject };
    }
    // Retry logic for OAuth token failure, if we receive 401 or 403 back, try to fetch a new token and make the API call a second time. If that fails again, return error as normal to the caller.
    if ((status === 401 || status === 403) && clientId && clientSecret) {
      const authHeader = init.headers.Authorization;
      const authHeaderValues = authHeader && authHeader.split(" ");
      if (authHeaderValues && authHeaderValues.length === 2 && !isRetry) {
        await this.updateOAuthAccessToken(requiredScopes, authHeaderValues[1]);
        return this.request(
          context,
          initOverrides,
          requiredScopes,
          true,
          microservice
        );
      }
    }
    let errorData = null;
    try {
      errorData = await response.json();
    } catch {
      throw response;
    }
    logObject.populateErrorInfo(response, errorData);
    this.createLogEntry(logObject);
    throw { statusCode: status, errorMessage: errorData };
  }

  protected async applyAuthToRequest(
    headerParameters: HTTPHeaders,
    authNames: string[],
    requiredScopes: string
  ) {
    const { bearerToken, clientId, clientSecret, username, password } =
      this.configuration;
    // for now, only support basic and oauth types.
    if (bearerToken != null) {
      headerParameters["Authorization"] = `Bearer ${bearerToken}`;
    } else if (authNames.indexOf("OAuth") >= 0 && clientId && clientSecret) {
      let scopes = this.standardizeScopes(requiredScopes);
      let accessToken = this.getOAuthAccessToken(scopes);
      if (!accessToken) {
        await this.updateOAuthAccessToken(scopes, null);
        accessToken = this.getOAuthAccessToken(scopes);
      }
      headerParameters["Authorization"] = `Bearer ${accessToken}`;
    } else if (username != null && password != null) {
      headerParameters["Authorization"] = this.createBasicAuthHeader(
        username,
        password
      );
    }
  }

  protected createLogEntry = (logObject: LogObject) => {
    if (logObject.getStatusCode() <= 299) {
      this.logger.info(logObject.toString());
    } else {
      this.logger.error(logObject.toString());
    }
  };

  private getOAuthAccessToken(scopes: string): string | null {
    const tokenMetadata = this.accessTokenMap.get(scopes);
    if (tokenMetadata) {
      const { accessToken, expiry } = tokenMetadata;
      const expirationTime = Math.floor(Date.now() / 1000) + 300;
      if (expirationTime < expiry) {
        return accessToken;
      }
    }
    return null;
  }

  private async updateOAuthAccessToken(scopes, accessToken) {
    const currentAccessToken = this.getOAuthAccessToken(scopes);
    // If the current access token is not set, or the cached token equals the token passed in
    // (which will only be passed in, in the event the token failed due to being invalid or some other failure scenario)
    if (!currentAccessToken || currentAccessToken === accessToken) {
      try {
        const tokenResponse = await this.buildOAuthRequest(scopes);
        let timestamp =
          Math.floor(Date.now() / 1000) + tokenResponse["expires_in"];
        this.accessTokenMap.set(scopes, {
          accessToken: tokenResponse["access_token"],
          expiry: timestamp,
        });
      } catch (err) {
        console.log(`OAuth2 Token retrieval failed. Error: ${err}`);
        throw new Error(`OAuth2 Token retrieval failed. Error: ${err}`);
      }
    }
  }

  private async buildOAuthRequest(scopes: string) {
    const { clientId, clientSecret } = this.configuration;
    await this.configuration.setOIDCUrls();
    const { tokenUrl } = this.configuration.oidcUrls;
    const response = await fetch(tokenUrl, {
      method: "POST",
      body: `grant_type=client_credentials&scope=${scopes}`,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        Authorization: this.createBasicAuthHeader(clientId, clientSecret),
        Accept: "application/json",
      },
    });
    const data = await response.json();
    return data;
  }

  private createBasicAuthHeader(username: string, password: string): string {
    const base64Encoded = Buffer.from(`${username}:${password}`).toString(
      "base64"
    );
    return `Basic ${base64Encoded}`;
  }

  private standardizeScopes(requiredScopes: string): string {
    const strArr = requiredScopes.split(" ");
    strArr.sort();
    return strArr.join(" ");
  }

  private createFetchParams({
    context,
    logObject,
    initOverrides,
    microservice,
  }: {
    context: RequestOpts;
    logObject: LogObject;
    initOverrides?: RequestInit;
    microservice: AvalaraMicroservice;
  }) {
    let url = this.configuration.getBasePath(microservice) + context.path;
    if (
      context.query !== undefined &&
      Object.keys(context.query).length !== 0
    ) {
      // only add the querystring to the URL if there are query parameters.
      // this is done to avoid urls ending with a "?" character which buggy webservers
      // do not handle correctly sometimes.
      url += "?" + this.configuration.queryParamsStringify(context.query);
    }
    logObject.populateRequestInfo(url, {
      body: context.body,
      method: context.method,
    });
    const body =
      (typeof FormData !== "undefined" && context.body instanceof FormData) ||
      context.body instanceof URLSearchParams ||
      isBlob(context.body)
        ? context.body
        : JSON.stringify(context.body);
    // timeout logic
    const controller = new AbortController();
    const timeout = this.configuration.timeout || 1200;
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    const headers = Object.assign(
      {},
      this.configuration.headers,
      context.headers
    );
    const { appName, appVersion, machineName } = this.configuration;
    headers[
      "X-Avalara-Client"
    ] = `${appName}; ${appVersion}; JavascriptSdk; ${this.sdkVersion}; ${machineName}`;
    const init: RequestInit = {
      method: context.method,
      headers,
      body,
      signal: controller.signal,
      ...initOverrides,
    };
    return { url, init, timeoutId };
  }

  private fetchApi = async (
    url: RequestInfo,
    init?: RequestInit,
    logObject?: LogObject
  ) => {
    let fetchParams = { url, init };
    for (const middleware of this.middleware) {
      if (middleware.pre) {
        fetchParams =
          (await middleware.pre({
            fetch: this.fetchApi,
            ...fetchParams,
          })) || fetchParams;
      }
    }
    let response = await fetch(fetchParams.url, fetchParams.init);
    logObject.populateElapsedTime();
    for (const middleware of this.middleware) {
      if (middleware.post) {
        response =
          (await middleware.post({
            fetch: this.fetchApi,
            url: fetchParams.url,
            init: fetchParams.init,
            response: response.clone(),
          })) || response;
      }
    }
    return response;
  };

  /**
   * Create a shallow clone of `this` by constructing a new instance
   * and then shallow cloning data members.
   */
  private clone<T extends ApiClient>(this: T): T {
    const constructor = this.constructor as any;
    const next = new constructor(this.configuration);
    next.middleware = this.middleware.slice();
    return next;
  }
}

export class RequiredError extends Error {
  name: "RequiredError" = "RequiredError";
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

export const COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|",
};

export type FetchAPI = typeof fetch;

export interface TokenMetadata {
  accessToken: string;
  expiry: number;
}

export interface OIDCMetadata {
  tokenUrl: string;
  deviceAuthorizationUrl: string;
}

export interface ConfigurationParameters {
  testBasePath?: string; // override base path when using the test environment
  testTokenUrl?: string; // override token URL for OAuth 2.0 flows when using the test environment
  testDeviceAuthorizationUrl?: string; // override device authorization URL for OAuth 2.0 flows when using the test environment
  // fetchApi?: FetchAPI; // override for fetch implementation
  middleware?: Middleware[]; // middleware to apply before/after fetch requests
  queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
  username?: string; // parameter for basic security
  password?: string; // parameter for basic security
  bearerToken?: string; // parameter for oauth2 security
  headers?: HTTPHeaders; //header params we want to use on every request
  appName: string; // Specify the name of your application here.  Should not contain any semicolons.
  appVersion: string; // Specify the version number of your application here.  Should not contain any semicolons.
  machineName: string; // Specify the machine name of the machine on which this code is executing here.  Should not contain any semicolons.
  environment: AvaTaxEnvironment; // Indicates which server to use.
  clientId?: string; // The ClientId used for the OAuth2 Client Credentials flow
  clientSecret?: string; // The ClientSecret used for the OAuth2 Client Credentials flow
  timeout?: number; // Specify the timeout for AvaTax requests in seconds; default value 20 minutes.
  logOptions?: LogOptions; // Specify the logging options to be utilized by the SDK.
}

export enum AvalaraMicroservice {
  EInvoicing = "einvoicing",
  A1099 = "a1099",
  None = "none",
}

export class Configuration {
  private oidcUrlObject: OIDCMetadata = null;
  constructor(private configuration: ConfigurationParameters) {}

  public getBasePath(microservice: AvalaraMicroservice): string {
    const { environment, testBasePath } = this.configuration;
    if (environment === AvaTaxEnvironment.Test && !testBasePath) {
      throw new Error(
        "TestBasePath must be configured to run in test environment mode."
      );
    }

    switch (microservice) {
      case AvalaraMicroservice.EInvoicing:
        switch (environment) {
          case AvaTaxEnvironment.Production:
            return EINVOICING_SERVICE_PRODUCTION_URL;
          case AvaTaxEnvironment.Sandbox:
            return EINVOICING_SERVICE_SANDBOX_URL;
          case AvaTaxEnvironment.QA:
            return EINVOICING_SERVICE_QA_URL;
          case AvaTaxEnvironment.DEV:
            return EINVOICING_SERVICE_DEV_URL;
          case AvaTaxEnvironment.Test:
            return testBasePath;
          default:
            throw new Error("Invalid Environment");
        }
      case AvalaraMicroservice.A1099:
        switch (environment) {
          case AvaTaxEnvironment.Production:
            return A1099_SERVICE_PRODUCTION_URL;
          case AvaTaxEnvironment.Sandbox:
            return A1099_SERVICE_SANDBOX_URL;
          case AvaTaxEnvironment.QA:
            return A1099_SERVICE_QA_URL;
          case AvaTaxEnvironment.DEV:
            return A1099_SERVICE_DEV_URL;
          case AvaTaxEnvironment.Test:
            return testBasePath;
          default:
            throw new Error("Invalid Environment");
        }
      case AvalaraMicroservice.None:
      default:
        throw new Error(
          'Environment not configured correctly, Acceptable values are "production", "sandbox", "qa", "dev", and "test".'
        );
    }
  }

  get basePath(): string {
    // Legacy getter for backward compatibility
    return this.getBasePath(AvalaraMicroservice.None);
  }

  get middleware(): Middleware[] {
    return this.configuration.middleware || [];
  }

  get queryParamsStringify(): (params: HTTPQuery) => string {
    return this.configuration.queryParamsStringify || querystring;
  }

  get appName(): string {
    return this.configuration.appName;
  }

  get appVersion(): string {
    return this.configuration.appVersion;
  }

  get machineName(): string {
    return this.configuration.machineName;
  }

  get username(): string | undefined {
    return this.configuration.username;
  }

  get password(): string | undefined {
    return this.configuration.password;
  }

  get clientId(): string {
    return this.configuration.clientId;
  }

  get clientSecret(): string {
    return this.configuration.clientSecret;
  }

  get timeout(): number {
    return this.configuration.timeout || 20;
  }

  get bearerToken(): string {
    return this.configuration.bearerToken;
  }

  get headers(): HTTPHeaders | undefined {
    return this.configuration.headers;
  }

  get environment(): AvaTaxEnvironment {
    return this.configuration.environment;
  }

  get testTokenUrl(): string {
    return this.configuration.testTokenUrl;
  }

  get testDeviceAuthorizationUrl(): string {
    return this.configuration.testDeviceAuthorizationUrl;
  }

  get oidcUrls(): OIDCMetadata {
    return this.oidcUrlObject;
  }

  get logOptions(): LogOptions | { logEnabled: boolean } {
    return this.configuration.logOptions || { logEnabled: false };
  }

  public async setOIDCUrls() {
    const { environment, testTokenUrl, testDeviceAuthorizationUrl } =
      this.configuration;
    if (environment === AvaTaxEnvironment.Test && testTokenUrl) {
      (this.oidcUrlObject || ({} as OIDCMetadata)).tokenUrl = testTokenUrl;
      (this.oidcUrlObject || ({} as OIDCMetadata)).deviceAuthorizationUrl =
        testDeviceAuthorizationUrl;
    } else if (!this.oidcUrlObject) {
      try {
        const response = await fetch(this.getOpenIdConnectUrl, {
          method: "GET",
        });
        const oidcDocument = await response.json();
        this.oidcUrlObject = {
          tokenUrl: oidcDocument["token_endpoint"],
          deviceAuthorizationUrl: oidcDocument["device_authorization_endpoint"],
        };
      } catch (ex) {
        console.log(
          `Exception when calling OpenIdConnect URL: ${this.getOpenIdConnectUrl} to fetch the token and device auth endpoint. Error: ${ex.message}. Defaulting to Fallback Token URL.`
        );
        this.oidcUrlObject = {
          tokenUrl: FALLBACK_TOKEN_URL,
          deviceAuthorizationUrl: FALLBACK_DEVICE_AUTHORIZATION_URL,
        };
      }
    }
  }

  get getOpenIdConnectUrl(): string {
    const { environment } = this.configuration;
    switch (environment) {
      case AvaTaxEnvironment.Production:
        return PRODUCTION_OPENID_CONFIG_URL;
      case AvaTaxEnvironment.Sandbox:
        return SANDBOX_OPENID_CONFIG_URL;
      case AvaTaxEnvironment.QA || AvaTaxEnvironment.Test:
        return QA_OPENID_CONFIG_URL;
    }
  }
}

export type Json = any;
export type HTTPMethod =
  | "GET"
  | "POST"
  | "PUT"
  | "PATCH"
  | "DELETE"
  | "OPTIONS"
  | "HEAD";
export type HTTPHeaders = { [key: string]: string };
export type HTTPQuery = {
  [key: string]:
    | string
    | number
    | null
    | boolean
    | Array<string | number | null | boolean>
    | HTTPQuery;
};
export type HTTPBody = Json | FormData | URLSearchParams;
export type ModelPropertyNaming =
  | "camelCase"
  | "snake_case"
  | "PascalCase"
  | "original";
export type ResponseWithLogObject = {
  response: Response;
  logObject: LogObject;
};

export interface FetchParams {
  url: string;
  init: RequestInit;
}

export interface RequestOpts {
  path: string;
  method: HTTPMethod;
  headers: HTTPHeaders;
  query?: HTTPQuery;
  body?: HTTPBody;
}

export function exists(json: any, key: string) {
  const value = json[key];
  return value !== null && value !== undefined;
}

export function querystring(params: HTTPQuery, prefix: string = ""): string {
  return Object.keys(params)
    .map((key) => {
      const fullKey = prefix + (prefix.length ? `[${key}]` : key);
      const value = params[key];
      if (value instanceof Array) {
        const multiValue = value
          .map((singleValue) => encodeURIComponent(String(singleValue)))
          .join(`&${encodeURIComponent(fullKey)}=`);
        return `${encodeURIComponent(fullKey)}=${multiValue}`;
      }
      if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(
          value.toISOString()
        )}`;
      }
      if (value instanceof Object) {
        return querystring(value as HTTPQuery, fullKey);
      }
      return `${encodeURIComponent(fullKey)}=${encodeURIComponent(
        String(value)
      )}`;
    })
    .filter((part) => part.length > 0)
    .join("&");
}

export function mapValues(data: any, fn: (item: any) => any) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}

export function canConsumeForm(consumes: Consume[]): boolean {
  for (const consume of consumes) {
    if ("multipart/form-data" === consume.contentType) {
      return true;
    }
  }
  return false;
}

export interface Consume {
  contentType: string;
}

export interface RequestContext {
  fetch: FetchAPI;
  url: RequestInfo;
  init: RequestInit;
}

export interface ResponseContext {
  fetch: FetchAPI;
  url: RequestInfo;
  init: RequestInit;
  response: Response;
}

export interface Middleware {
  pre?(context: RequestContext): Promise<FetchParams>;
  post?(context: ResponseContext): Promise<Response>;
}

export interface ApiResponse<T> {
  raw: Response;
  value(): Promise<T>;
}

export interface ResponseTransformer<T> {
  (json: any): T;
}

export interface IOpenIdConnectURLs {
  token_endpoint: string;
}

export class JSONApiResponse<T> {
  constructor(
    public raw: Response,
    private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue
  ) {}

  async value(): Promise<T> {
    return this.transformer(await this.raw.json());
  }
}

export class VoidApiResponse {
  constructor(public raw: Response) {}

  async value(): Promise<void> {
    return undefined;
  }
}

export class BlobApiResponse {
  constructor(public raw: Response) {}

  async value(): Promise<Blob> {
    return await this.raw.blob();
  }
}

export class TextApiResponse {
  constructor(public raw: Response) {}

  async value(): Promise<string> {
    return await this.raw.text();
  }
}

export enum AvaTaxEnvironment {
  Production = "prod",
  Sandbox = "sandbox",
  Test = "test",
  QA = "qa",
  DEV = "dev",
}
