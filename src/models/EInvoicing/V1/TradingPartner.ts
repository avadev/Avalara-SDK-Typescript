/* tslint:disable */
/* eslint-disable */
/**
 * Avalara E-Invoicing API
 * An API that supports sending data for an E-Invoicing compliance use-case.
 *
 * The version of the OpenAPI document: 1.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../../../runtime';
import {
    Address,
    AddressFromJSON,
    AddressFromJSONTyped,
    AddressToJSON,
} from './Address';
import {
    Consents,
    ConsentsFromJSON,
    ConsentsFromJSONTyped,
    ConsentsToJSON,
} from './Consents';
import {
    Extension,
    ExtensionFromJSON,
    ExtensionFromJSONTyped,
    ExtensionToJSON,
} from './Extension';
import {
    Identifier,
    IdentifierFromJSON,
    IdentifierFromJSONTyped,
    IdentifierToJSON,
} from './Identifier';
import {
    SupportedDocumentTypes,
    SupportedDocumentTypesFromJSON,
    SupportedDocumentTypesFromJSONTyped,
    SupportedDocumentTypesToJSON,
} from './SupportedDocumentTypes';

/**
 * Represents a participant in the Avalara directory.
 * @export
 * @interface TradingPartner
 */
export interface TradingPartner {
    /**
     * Avalara unique ID of the participant in the directory.
     * @type {string}
     * @memberof TradingPartner
     */
    readonly id?: string;
    /**
     * Name of the participant (typically, the name of the business entity).
     * @type {string}
     * @memberof TradingPartner
     */
    name: string;
    /**
     * The network where the participant is present. When creating or updating a trading partner, the value provided for the attribute 'network' will be ignored.
     * @type {string}
     * @memberof TradingPartner
     */
    readonly network?: string;
    /**
     * Registration date of the participant if available.
     * @type {string}
     * @memberof TradingPartner
     */
    registrationDate?: string;
    /**
     * A list of identifiers associated with the trading partner. Each identifier should consistently include the fields name, and value to maintain clarity and ensure consistent structure across entries. When creating or updating a trading partner, the attribute 'name' must be agreed upon with Avalara to ensure consistency. Failing to adhere to the agreed values will result in a validation error. Further, when creating or updating a trading partner, the value provided for the attribute 'displayName' will be ignored and instead retrieved from the standard set of display names maintained.
     * @type {Array<Identifier>}
     * @memberof TradingPartner
     */
    identifiers: Array<Identifier>;
    /**
     * 
     * @type {Array<Address>}
     * @memberof TradingPartner
     */
    addresses: Array<Address>;
    /**
     * A list of document types supported by the trading partner for exchange. Each document type identifier value must match the standard list maintained by Avalara, which includes Peppol and other public network document type identifier schemes and values, as well as any approved partner-specific identifiers. The 'value' field must exactly match an entry from the provided document identifier list. Any attempt to submit unsupported document types will result in a validation error. Further, when creating or updating a trading partner, the value provided for the attributes 'name' and 'supportedByAvalara' will be ignored.
     * @type {Array<SupportedDocumentTypes>}
     * @memberof TradingPartner
     */
    supportedDocumentTypes: Array<SupportedDocumentTypes>;
    /**
     * 
     * @type {Consents}
     * @memberof TradingPartner
     */
    consents?: Consents;
    /**
     * Optional array used to carry additional metadata or configuration values that may be required by specific networks. When creating or updating a trading partner, the keys provided in the 'extensions' attribute must be selected from a predefined list of supported extensions. Using any unsupported keys will result in a validation error.
     * @type {Array<Extension>}
     * @memberof TradingPartner
     */
    extensions?: Array<Extension>;
}



/**
 * Check if a given object implements the TradingPartner interface.
 */
export function instanceOfTradingPartner(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "name" in value;
    isInstance = isInstance && "identifiers" in value;
    isInstance = isInstance && "addresses" in value;
    isInstance = isInstance && "supportedDocumentTypes" in value;

    return isInstance;
}

export function TradingPartnerFromJSON(json: any): TradingPartner {
    return TradingPartnerFromJSONTyped(json, false);
}

export function TradingPartnerFromJSONTyped(json: any, ignoreDiscriminator: boolean): TradingPartner {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'id': !exists(json, 'id') ? undefined : json['id'],
        'name': json['name'],
        'network': !exists(json, 'network') ? undefined : json['network'],
        'registrationDate': !exists(json, 'registrationDate') ? undefined : json['registrationDate'],
        'identifiers': ((json['identifiers'] as Array<any>)?.map(IdentifierFromJSON)),
        'addresses': ((json['addresses'] as Array<any>)?.map(AddressFromJSON)),
        'supportedDocumentTypes': ((json['supportedDocumentTypes'] as Array<any>)?.map(SupportedDocumentTypesFromJSON)),
        'consents': !exists(json, 'consents') ? undefined : ConsentsFromJSON(json['consents']),
        'extensions': !exists(json, 'extensions') ? undefined : ((json['extensions'] as Array<any>)?.map(ExtensionFromJSON)),
    };
}

export function TradingPartnerToJSON(value?: TradingPartner | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'name': value.name,
        'registrationDate': value.registrationDate,
        'identifiers': ((value.identifiers as Array<any>)?.map(IdentifierToJSON)),
        'addresses': ((value.addresses as Array<any>)?.map(AddressToJSON)),
        'supportedDocumentTypes': ((value.supportedDocumentTypes as Array<any>)?.map(SupportedDocumentTypesToJSON)),
        'consents': ConsentsToJSON(value.consents),
        'extensions': value.extensions === undefined ? undefined : ((value.extensions as Array<any>)?.map(ExtensionToJSON)),
    };
}
