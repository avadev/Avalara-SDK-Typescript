/* tslint:disable */
/* eslint-disable */
/**
 * Avalara E-Invoicing API
 * An API that supports sending data for an E-Invoicing compliance use-case.
 *
 * The version of the OpenAPI document: 1.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../../../runtime';
import { RequestInit } from 'node-fetch';
import LogObject from '../../../utils/logObject';

import {
    BadDownloadRequest,
    BadDownloadRequestFromJSON,
    BadDownloadRequestToJSON,
    BadRequest,
    BadRequestFromJSON,
    BadRequestToJSON,
    DocumentFetch,
    DocumentFetchFromJSON,
    DocumentFetchToJSON,
    DocumentFetchRequest,
    DocumentFetchRequestFromJSON,
    DocumentFetchRequestToJSON,
    DocumentListResponse,
    DocumentListResponseFromJSON,
    DocumentListResponseToJSON,
    DocumentStatusResponse,
    DocumentStatusResponseFromJSON,
    DocumentStatusResponseToJSON,
    DocumentSubmissionError,
    DocumentSubmissionErrorFromJSON,
    DocumentSubmissionErrorToJSON,
    DocumentSubmitResponse,
    DocumentSubmitResponseFromJSON,
    DocumentSubmitResponseToJSON,
    ForbiddenError,
    ForbiddenErrorFromJSON,
    ForbiddenErrorToJSON,
    InternalServerError,
    InternalServerErrorFromJSON,
    InternalServerErrorToJSON,
    NotFoundError,
    NotFoundErrorFromJSON,
    NotFoundErrorToJSON,
    SubmitDocumentMetadata,
    SubmitDocumentMetadataFromJSON,
    SubmitDocumentMetadataToJSON,
} from '../../../packages/EInvoicing/V1';

export interface DownloadDocumentInterface {
    avalaraVersion: string;
    accept: string;
    documentId: string;
    xAvalaraClient?: string;
}

export interface FetchDocumentsInterface {
    avalaraVersion: string;
    documentFetchRequest: DocumentFetchRequest;
    xAvalaraClient?: string;
}

export interface GetDocumentListInterface {
    avalaraVersion: string;
    xAvalaraClient?: string;
    startDate?: Date;
    endDate?: Date;
    flow?: string;
    $count?: string;
    $countOnly?: string;
    $filter?: string;
    $top?: number;
    $skip?: string;
}

export interface GetDocumentStatusInterface {
    avalaraVersion: string;
    documentId: string;
    xAvalaraClient?: string;
}

export interface SubmitDocumentInterface {
    avalaraVersion: string;
    metadata: SubmitDocumentMetadata;
    data: string;
    xAvalaraClient?: string;
}

/**
 * 
 */
export class DocumentsApi extends runtime.ApiClient {
    public sdkVersion: string = '';

    constructor(apiClient: runtime.ApiClient) {
        super(apiClient.configuration);
    }

    /**
     * When the document is available, use this endpoint to download it as text, XML, or PDF. The output format needs to be specified in the Accept header, and it will vary depending on the mandate. If the file has not yet been created, then status code 404 (not found) is returned.
     * Returns a copy of the document
     */
    async downloadDocumentRaw(requestParameters: DownloadDocumentInterface, initOverrides?: RequestInit): Promise<{ response: runtime.ApiResponse<Blob>, logObject: LogObject }> {
        if (requestParameters.avalaraVersion === null || requestParameters.avalaraVersion === undefined) {
            throw new runtime.RequiredError('avalaraVersion','Required parameter requestParameters.avalaraVersion was null or undefined when calling downloadDocument.');
        }

        if (requestParameters.accept === null || requestParameters.accept === undefined) {
            throw new runtime.RequiredError('accept','Required parameter requestParameters.accept was null or undefined when calling downloadDocument.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling downloadDocument.');
        }

        const queryParameters: any = {};
        const requiredScopes = "";
        const authNames: string[] = ['http'];
        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['avalara-version'] = '1.2';

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (requestParameters.xAvalaraClient !== undefined && requestParameters.xAvalaraClient !== null) {
            headerParameters['X-Avalara-Client'] = String(requestParameters.xAvalaraClient);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const { response, logObject } = await this.request({
            path: `/einvoicing/documents/{documentId}/$download`.replace(`{${"documentId"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides, requiredScopes);
        logObject.populateResponseInfo(response);
        return { response: new runtime.BlobApiResponse(response), logObject };
    }

    /**
     * When the document is available, use this endpoint to download it as text, XML, or PDF. The output format needs to be specified in the Accept header, and it will vary depending on the mandate. If the file has not yet been created, then status code 404 (not found) is returned.
     * Returns a copy of the document
     */
    async downloadDocument(requestParameters: DownloadDocumentInterface, initOverrides?: RequestInit): Promise<Blob> {
        const { response, logObject } = await this.downloadDocumentRaw(requestParameters, initOverrides);
        const value = await response.value();
        logObject.populateResponseBody(value);
        this.createLogEntry(logObject);
        return value;
    }

    /**
     * This API allows you to retrieve an inbound document. Pass key-value pairs as parameters in the request, such as the confirmation number, supplier number, and buyer VAT number.
     * Fetch the inbound document from a tax authority
     */
    async fetchDocumentsRaw(requestParameters: FetchDocumentsInterface, initOverrides?: RequestInit): Promise<{ response: runtime.ApiResponse<DocumentFetch>, logObject: LogObject }> {
        if (requestParameters.avalaraVersion === null || requestParameters.avalaraVersion === undefined) {
            throw new runtime.RequiredError('avalaraVersion','Required parameter requestParameters.avalaraVersion was null or undefined when calling fetchDocuments.');
        }

        if (requestParameters.documentFetchRequest === null || requestParameters.documentFetchRequest === undefined) {
            throw new runtime.RequiredError('documentFetchRequest','Required parameter requestParameters.documentFetchRequest was null or undefined when calling fetchDocuments.');
        }

        const queryParameters: any = {};
        const requiredScopes = "";
        const authNames: string[] = ['http'];
        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['avalara-version'] = '1.2';

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xAvalaraClient !== undefined && requestParameters.xAvalaraClient !== null) {
            headerParameters['X-Avalara-Client'] = String(requestParameters.xAvalaraClient);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const { response, logObject } = await this.request({
            path: `/einvoicing/documents/$fetch`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentFetchRequestToJSON(requestParameters.documentFetchRequest),
        }, initOverrides, requiredScopes);
        logObject.populateResponseInfo(response);
        return { response: new runtime.JSONApiResponse(response, (jsonValue) => DocumentFetchFromJSON(jsonValue)), logObject };
    }

    /**
     * This API allows you to retrieve an inbound document. Pass key-value pairs as parameters in the request, such as the confirmation number, supplier number, and buyer VAT number.
     * Fetch the inbound document from a tax authority
     */
    async fetchDocuments(requestParameters: FetchDocumentsInterface, initOverrides?: RequestInit): Promise<DocumentFetch> {
        const { response, logObject } = await this.fetchDocumentsRaw(requestParameters, initOverrides);
        const value = await response.value();
        logObject.populateResponseBody(value);
        this.createLogEntry(logObject);
        return value;
    }

    /**
     * Get a list of documents on the Avalara E-Invoicing platform that have a processing date within the specified date range.
     * Returns a summary of documents for a date range
     */
    async getDocumentListRaw(requestParameters: GetDocumentListInterface, initOverrides?: RequestInit): Promise<{ response: runtime.ApiResponse<DocumentListResponse>, logObject: LogObject }> {
        if (requestParameters.avalaraVersion === null || requestParameters.avalaraVersion === undefined) {
            throw new runtime.RequiredError('avalaraVersion','Required parameter requestParameters.avalaraVersion was null or undefined when calling getDocumentList.');
        }

        const queryParameters: any = {};
        const requiredScopes = "";
        const authNames: string[] = ['http'];
        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = (requestParameters.startDate as any).toISOString();
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['endDate'] = (requestParameters.endDate as any).toISOString();
        }

        if (requestParameters.flow !== undefined) {
            queryParameters['flow'] = requestParameters.flow;
        }

        if (requestParameters.$count !== undefined) {
            queryParameters['$count'] = requestParameters.$count;
        }

        if (requestParameters.$countOnly !== undefined) {
            queryParameters['$countOnly'] = requestParameters.$countOnly;
        }

        if (requestParameters.$filter !== undefined) {
            queryParameters['$filter'] = requestParameters.$filter;
        }

        if (requestParameters.$top !== undefined) {
            queryParameters['$top'] = requestParameters.$top;
        }

        if (requestParameters.$skip !== undefined) {
            queryParameters['$skip'] = requestParameters.$skip;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['avalara-version'] = '1.2';

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xAvalaraClient !== undefined && requestParameters.xAvalaraClient !== null) {
            headerParameters['X-Avalara-Client'] = String(requestParameters.xAvalaraClient);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const { response, logObject } = await this.request({
            path: `/einvoicing/documents`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides, requiredScopes);
        logObject.populateResponseInfo(response);
        return { response: new runtime.JSONApiResponse(response, (jsonValue) => DocumentListResponseFromJSON(jsonValue)), logObject };
    }

    /**
     * Get a list of documents on the Avalara E-Invoicing platform that have a processing date within the specified date range.
     * Returns a summary of documents for a date range
     */
    async getDocumentList(requestParameters: GetDocumentListInterface, initOverrides?: RequestInit): Promise<DocumentListResponse> {
        const { response, logObject } = await this.getDocumentListRaw(requestParameters, initOverrides);
        const value = await response.value();
        logObject.populateResponseBody(value);
        this.createLogEntry(logObject);
        return value;
    }

    /**
     * Using the unique ID from POST /einvoicing/documents response body, request the current status of a document.
     * Checks the status of a document
     */
    async getDocumentStatusRaw(requestParameters: GetDocumentStatusInterface, initOverrides?: RequestInit): Promise<{ response: runtime.ApiResponse<DocumentStatusResponse>, logObject: LogObject }> {
        if (requestParameters.avalaraVersion === null || requestParameters.avalaraVersion === undefined) {
            throw new runtime.RequiredError('avalaraVersion','Required parameter requestParameters.avalaraVersion was null or undefined when calling getDocumentStatus.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling getDocumentStatus.');
        }

        const queryParameters: any = {};
        const requiredScopes = "";
        const authNames: string[] = ['http'];
        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['avalara-version'] = '1.2';

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xAvalaraClient !== undefined && requestParameters.xAvalaraClient !== null) {
            headerParameters['X-Avalara-Client'] = String(requestParameters.xAvalaraClient);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const { response, logObject } = await this.request({
            path: `/einvoicing/documents/{documentId}/status`.replace(`{${"documentId"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides, requiredScopes);
        logObject.populateResponseInfo(response);
        return { response: new runtime.JSONApiResponse(response, (jsonValue) => DocumentStatusResponseFromJSON(jsonValue)), logObject };
    }

    /**
     * Using the unique ID from POST /einvoicing/documents response body, request the current status of a document.
     * Checks the status of a document
     */
    async getDocumentStatus(requestParameters: GetDocumentStatusInterface, initOverrides?: RequestInit): Promise<DocumentStatusResponse> {
        const { response, logObject } = await this.getDocumentStatusRaw(requestParameters, initOverrides);
        const value = await response.value();
        logObject.populateResponseBody(value);
        this.createLogEntry(logObject);
        return value;
    }

    /**
     * When a UBL document is sent to this endpoint, it generates a document in the required format as mandated by the specified country. Additionally, it initiates the workflow to transmit the generated document to the relevant tax authority, if necessary.<br><br>The response from the endpoint contains a unique document ID, which can be used to request the status of the document and verify if it was successfully accepted at the destination.<br><br>Furthermore, the unique ID enables the download of a copy of the generated document for reference purposes.
     * Submits a document to Avalara E-Invoicing API
     */
    async submitDocumentRaw(requestParameters: SubmitDocumentInterface, initOverrides?: RequestInit): Promise<{ response: runtime.ApiResponse<DocumentSubmitResponse>, logObject: LogObject }> {
        if (requestParameters.avalaraVersion === null || requestParameters.avalaraVersion === undefined) {
            throw new runtime.RequiredError('avalaraVersion','Required parameter requestParameters.avalaraVersion was null or undefined when calling submitDocument.');
        }

        if (requestParameters.metadata === null || requestParameters.metadata === undefined) {
            throw new runtime.RequiredError('metadata','Required parameter requestParameters.metadata was null or undefined when calling submitDocument.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling submitDocument.');
        }

        const queryParameters: any = {};
        const requiredScopes = "";
        const authNames: string[] = ['http'];
        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['avalara-version'] = '1.2';

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xAvalaraClient !== undefined && requestParameters.xAvalaraClient !== null) {
            headerParameters['X-Avalara-Client'] = String(requestParameters.xAvalaraClient);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.metadata !== undefined) {
            formParams.append('metadata', new Blob([JSON.stringify(SubmitDocumentMetadataToJSON(requestParameters.metadata))], { type: "application/json", }));
        }

        if (requestParameters.data !== undefined) {
            formParams.append('data', requestParameters.data as any);
        }

        const { response, logObject } = await this.request({
            path: `/einvoicing/documents`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides, requiredScopes);
        logObject.populateResponseInfo(response);
        return { response: new runtime.JSONApiResponse(response, (jsonValue) => DocumentSubmitResponseFromJSON(jsonValue)), logObject };
    }

    /**
     * When a UBL document is sent to this endpoint, it generates a document in the required format as mandated by the specified country. Additionally, it initiates the workflow to transmit the generated document to the relevant tax authority, if necessary.<br><br>The response from the endpoint contains a unique document ID, which can be used to request the status of the document and verify if it was successfully accepted at the destination.<br><br>Furthermore, the unique ID enables the download of a copy of the generated document for reference purposes.
     * Submits a document to Avalara E-Invoicing API
     */
    async submitDocument(requestParameters: SubmitDocumentInterface, initOverrides?: RequestInit): Promise<DocumentSubmitResponse> {
        const { response, logObject } = await this.submitDocumentRaw(requestParameters, initOverrides);
        const value = await response.value();
        logObject.populateResponseBody(value);
        this.createLogEntry(logObject);
        return value;
    }

}
