/* tslint:disable */
/* eslint-disable */
/**
 * Avalara E-Invoicing API
 * An API that supports sending data for an E-Invoicing compliance use-case.
 *
 * The version of the OpenAPI document: 1.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../../../runtime';
import { RequestInit } from 'node-fetch';
import LogObject from '../../../utils/logObject';

import {
    BatchSearch,
    BatchSearchFromJSON,
    BatchSearchToJSON,
    BatchSearchListResponse,
    BatchSearchListResponseFromJSON,
    BatchSearchListResponseToJSON,
    BatchSearchParticipants202Response,
    BatchSearchParticipants202ResponseFromJSON,
    BatchSearchParticipants202ResponseToJSON,
    CreateTradingPartner201Response,
    CreateTradingPartner201ResponseFromJSON,
    CreateTradingPartner201ResponseToJSON,
    CreateTradingPartnersBatch200Response,
    CreateTradingPartnersBatch200ResponseFromJSON,
    CreateTradingPartnersBatch200ResponseToJSON,
    CreateTradingPartnersBatchRequest,
    CreateTradingPartnersBatchRequestFromJSON,
    CreateTradingPartnersBatchRequestToJSON,
    ErrorResponse,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    SearchParticipants200Response,
    SearchParticipants200ResponseFromJSON,
    SearchParticipants200ResponseToJSON,
    TradingPartner,
    TradingPartnerFromJSON,
    TradingPartnerToJSON,
    UpdateTradingPartner200Response,
    UpdateTradingPartner200ResponseFromJSON,
    UpdateTradingPartner200ResponseToJSON,
} from '../../../packages/EInvoicing/V1';

export interface BatchSearchParticipantsInterface {
    avalaraVersion?: string;
    name: string;
    notificationEmail: string;
    file: Blob;
    xAvalaraClient?: string;
    xCorrelationID?: string;
}

export interface CreateTradingPartnerInterface {
    avalaraVersion?: string;
    tradingPartner: TradingPartner;
    xAvalaraClient?: string;
    xCorrelationID?: string;
}

export interface CreateTradingPartnersBatchOperationInterface {
    avalaraVersion?: string;
    createTradingPartnersBatchRequest: CreateTradingPartnersBatchRequest;
    xAvalaraClient?: string;
    xCorrelationID?: string;
}

export interface DeleteTradingPartnerInterface {
    avalaraVersion?: string;
    id: string;
    xAvalaraClient?: string;
    xCorrelationID?: string;
}

export interface DownloadBatchSearchReportInterface {
    avalaraVersion?: string;
    id: string;
    xAvalaraClient?: string;
    xCorrelationID?: string;
}

export interface GetBatchSearchDetailInterface {
    avalaraVersion?: string;
    id: string;
    xAvalaraClient?: string;
    xCorrelationID?: string;
}

export interface ListBatchSearchesInterface {
    avalaraVersion?: string;
    xAvalaraClient?: string;
    $filter?: string;
    count?: boolean;
    $top?: number;
    $skip?: number;
    $orderBy?: string;
    xCorrelationID?: string;
}

export interface SearchParticipantsInterface {
    avalaraVersion?: string;
    $search: string;
    xAvalaraClient?: string;
    count?: boolean;
    $filter?: string;
    $top?: number;
    $skip?: number;
    $orderBy?: string;
    xCorrelationID?: string;
}

export interface UpdateTradingPartnerInterface {
    avalaraVersion?: string;
    id: string;
    tradingPartner: TradingPartner;
    xAvalaraClient?: string;
    xCorrelationID?: string;
}

/**
 * 
 */
export class TradingPartnersApi extends runtime.ApiClient {
    public sdkVersion: string = '25.8.3';

    constructor(apiClient: runtime.ApiClient) {
        super(apiClient.configuration);
    }

    /**
     * This endpoint creates a batch search and performs a batch search in the directory for participants in the background.
     * Handles batch search requests by uploading a file containing search parameters.
     */
    async batchSearchParticipantsRaw(requestParameters: BatchSearchParticipantsInterface, initOverrides?: RequestInit): Promise<{ response: runtime.ApiResponse<BatchSearchParticipants202Response>, logObject: LogObject }> {
        requestParameters.avalaraVersion = requestParameters.avalaraVersion || '1.4';
        if (requestParameters.avalaraVersion === null || requestParameters.avalaraVersion === undefined) {
            throw new runtime.RequiredError('avalaraVersion','Required parameter requestParameters.avalaraVersion was null or undefined when calling batchSearchParticipants.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling batchSearchParticipants.');
        }

        if (requestParameters.notificationEmail === null || requestParameters.notificationEmail === undefined) {
            throw new runtime.RequiredError('notificationEmail','Required parameter requestParameters.notificationEmail was null or undefined when calling batchSearchParticipants.');
        }

        if (requestParameters.file === null || requestParameters.file === undefined) {
            throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling batchSearchParticipants.');
        }

        const queryParameters: any = {};
        const requiredScopes = "";
        const authNames: string[] = ['http'];
        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.notificationEmail !== undefined) {
            queryParameters['notificationEmail'] = requestParameters.notificationEmail;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xAvalaraClient !== undefined && requestParameters.xAvalaraClient !== null) {
            headerParameters['X-Avalara-Client'] = String(requestParameters.xAvalaraClient);
        }

        if (requestParameters.xCorrelationID !== undefined && requestParameters.xCorrelationID !== null) {
            headerParameters['X-Correlation-ID'] = String(requestParameters.xCorrelationID);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        const { response, logObject } = await this.request({
            path: `/einvoicing/trading-partners/batch-searches`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides, requiredScopes, false, runtime.AvalaraMicroservice.EInvoicing);
        logObject.populateResponseInfo(response);
        return { response: new runtime.JSONApiResponse(response, (jsonValue) => BatchSearchParticipants202ResponseFromJSON(jsonValue)), logObject };
    }

    /**
     * This endpoint creates a batch search and performs a batch search in the directory for participants in the background.
     * Handles batch search requests by uploading a file containing search parameters.
     */
    async batchSearchParticipants(requestParameters: BatchSearchParticipantsInterface, initOverrides?: RequestInit): Promise<BatchSearchParticipants202Response> {
        const { response, logObject } = await this.batchSearchParticipantsRaw(requestParameters, initOverrides);
        const value = await response.value();
        logObject.populateResponseBody(value);
        this.createLogEntry(logObject);
        return value;
    }

    /**
     * This endpoint creates a new trading partner with the provided details. The request body must include the necessary information as defined in the `TradingPartner` schema.
     * Creates a new trading partner.
     */
    async createTradingPartnerRaw(requestParameters: CreateTradingPartnerInterface, initOverrides?: RequestInit): Promise<{ response: runtime.ApiResponse<CreateTradingPartner201Response>, logObject: LogObject }> {
        requestParameters.avalaraVersion = requestParameters.avalaraVersion || '1.4';
        if (requestParameters.avalaraVersion === null || requestParameters.avalaraVersion === undefined) {
            throw new runtime.RequiredError('avalaraVersion','Required parameter requestParameters.avalaraVersion was null or undefined when calling createTradingPartner.');
        }

        if (requestParameters.tradingPartner === null || requestParameters.tradingPartner === undefined) {
            throw new runtime.RequiredError('tradingPartner','Required parameter requestParameters.tradingPartner was null or undefined when calling createTradingPartner.');
        }

        const queryParameters: any = {};
        const requiredScopes = "";
        const authNames: string[] = ['http'];
        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xAvalaraClient !== undefined && requestParameters.xAvalaraClient !== null) {
            headerParameters['X-Avalara-Client'] = String(requestParameters.xAvalaraClient);
        }

        if (requestParameters.xCorrelationID !== undefined && requestParameters.xCorrelationID !== null) {
            headerParameters['X-Correlation-ID'] = String(requestParameters.xCorrelationID);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const { response, logObject } = await this.request({
            path: `/einvoicing/trading-partners`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TradingPartnerToJSON(requestParameters.tradingPartner),
        }, initOverrides, requiredScopes, false, runtime.AvalaraMicroservice.EInvoicing);
        logObject.populateResponseInfo(response);
        return { response: new runtime.JSONApiResponse(response, (jsonValue) => CreateTradingPartner201ResponseFromJSON(jsonValue)), logObject };
    }

    /**
     * This endpoint creates a new trading partner with the provided details. The request body must include the necessary information as defined in the `TradingPartner` schema.
     * Creates a new trading partner.
     */
    async createTradingPartner(requestParameters: CreateTradingPartnerInterface, initOverrides?: RequestInit): Promise<CreateTradingPartner201Response> {
        const { response, logObject } = await this.createTradingPartnerRaw(requestParameters, initOverrides);
        const value = await response.value();
        logObject.populateResponseBody(value);
        this.createLogEntry(logObject);
        return value;
    }

    /**
     * This endpoint creates multiple trading partners in a single batch request. It accepts an array of trading partners and processes them synchronously. Supports a maximum of 100 records or 1 MB request payload. The batch is processed atomically and partial success is not allowed.
     * Creates a batch of multiple trading partners.
     */
    async createTradingPartnersBatchRaw(requestParameters: CreateTradingPartnersBatchOperationInterface, initOverrides?: RequestInit): Promise<{ response: runtime.ApiResponse<CreateTradingPartnersBatch200Response>, logObject: LogObject }> {
        requestParameters.avalaraVersion = requestParameters.avalaraVersion || '1.4';
        if (requestParameters.avalaraVersion === null || requestParameters.avalaraVersion === undefined) {
            throw new runtime.RequiredError('avalaraVersion','Required parameter requestParameters.avalaraVersion was null or undefined when calling createTradingPartnersBatch.');
        }

        if (requestParameters.createTradingPartnersBatchRequest === null || requestParameters.createTradingPartnersBatchRequest === undefined) {
            throw new runtime.RequiredError('createTradingPartnersBatchRequest','Required parameter requestParameters.createTradingPartnersBatchRequest was null or undefined when calling createTradingPartnersBatch.');
        }

        const queryParameters: any = {};
        const requiredScopes = "";
        const authNames: string[] = ['http'];
        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xAvalaraClient !== undefined && requestParameters.xAvalaraClient !== null) {
            headerParameters['X-Avalara-Client'] = String(requestParameters.xAvalaraClient);
        }

        if (requestParameters.xCorrelationID !== undefined && requestParameters.xCorrelationID !== null) {
            headerParameters['X-Correlation-ID'] = String(requestParameters.xCorrelationID);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const { response, logObject } = await this.request({
            path: `/einvoicing/trading-partners/batch`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateTradingPartnersBatchRequestToJSON(requestParameters.createTradingPartnersBatchRequest),
        }, initOverrides, requiredScopes, false, runtime.AvalaraMicroservice.EInvoicing);
        logObject.populateResponseInfo(response);
        return { response: new runtime.JSONApiResponse(response, (jsonValue) => CreateTradingPartnersBatch200ResponseFromJSON(jsonValue)), logObject };
    }

    /**
     * This endpoint creates multiple trading partners in a single batch request. It accepts an array of trading partners and processes them synchronously. Supports a maximum of 100 records or 1 MB request payload. The batch is processed atomically and partial success is not allowed.
     * Creates a batch of multiple trading partners.
     */
    async createTradingPartnersBatch(requestParameters: CreateTradingPartnersBatchOperationInterface, initOverrides?: RequestInit): Promise<CreateTradingPartnersBatch200Response> {
        const { response, logObject } = await this.createTradingPartnersBatchRaw(requestParameters, initOverrides);
        const value = await response.value();
        logObject.populateResponseBody(value);
        this.createLogEntry(logObject);
        return value;
    }

    /**
     * This endpoint deletes an existing trading partner identified by the provided ID.
     * Deletes a trading partner using ID.
     */
    async deleteTradingPartnerRaw(requestParameters: DeleteTradingPartnerInterface, initOverrides?: RequestInit): Promise<{ response: runtime.ApiResponse<void>, logObject: LogObject }> {
        requestParameters.avalaraVersion = requestParameters.avalaraVersion || '1.4';
        if (requestParameters.avalaraVersion === null || requestParameters.avalaraVersion === undefined) {
            throw new runtime.RequiredError('avalaraVersion','Required parameter requestParameters.avalaraVersion was null or undefined when calling deleteTradingPartner.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteTradingPartner.');
        }

        const queryParameters: any = {};
        const requiredScopes = "";
        const authNames: string[] = ['http'];
        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xAvalaraClient !== undefined && requestParameters.xAvalaraClient !== null) {
            headerParameters['X-Avalara-Client'] = String(requestParameters.xAvalaraClient);
        }

        if (requestParameters.xCorrelationID !== undefined && requestParameters.xCorrelationID !== null) {
            headerParameters['X-Correlation-ID'] = String(requestParameters.xCorrelationID);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const { response, logObject } = await this.request({
            path: `/einvoicing/trading-partners/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides, requiredScopes, false, runtime.AvalaraMicroservice.EInvoicing);
        logObject.populateResponseInfo(response);
        return { response: new runtime.VoidApiResponse(response), logObject };
    }

    /**
     * This endpoint deletes an existing trading partner identified by the provided ID.
     * Deletes a trading partner using ID.
     */
    async deleteTradingPartner(requestParameters: DeleteTradingPartnerInterface, initOverrides?: RequestInit): Promise<void> {
        const { logObject } = await this.deleteTradingPartnerRaw(requestParameters, initOverrides);
        logObject.populateResponseBody(null);
        this.createLogEntry(logObject);
    }

    /**
     * This endpoint downloads the report for a specific batch search using the batch search ID. It returns a CSV file containing up to 1,000 query results.
     * Downloads batch search results in a csv file.
     */
    async downloadBatchSearchReportRaw(requestParameters: DownloadBatchSearchReportInterface, initOverrides?: RequestInit): Promise<{ response: runtime.ApiResponse<Blob>, logObject: LogObject }> {
        requestParameters.avalaraVersion = requestParameters.avalaraVersion || '1.4';
        if (requestParameters.avalaraVersion === null || requestParameters.avalaraVersion === undefined) {
            throw new runtime.RequiredError('avalaraVersion','Required parameter requestParameters.avalaraVersion was null or undefined when calling downloadBatchSearchReport.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling downloadBatchSearchReport.');
        }

        const queryParameters: any = {};
        const requiredScopes = "";
        const authNames: string[] = ['http'];
        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xAvalaraClient !== undefined && requestParameters.xAvalaraClient !== null) {
            headerParameters['X-Avalara-Client'] = String(requestParameters.xAvalaraClient);
        }

        if (requestParameters.xCorrelationID !== undefined && requestParameters.xCorrelationID !== null) {
            headerParameters['X-Correlation-ID'] = String(requestParameters.xCorrelationID);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const { response, logObject } = await this.request({
            path: `/einvoicing/trading-partners/batch-searches/{id}/$download-results`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides, requiredScopes, false, runtime.AvalaraMicroservice.EInvoicing);
        logObject.populateResponseInfo(response);
        return { response: new runtime.BlobApiResponse(response), logObject };
    }

    /**
     * This endpoint downloads the report for a specific batch search using the batch search ID. It returns a CSV file containing up to 1,000 query results.
     * Downloads batch search results in a csv file.
     */
    async downloadBatchSearchReport(requestParameters: DownloadBatchSearchReportInterface, initOverrides?: RequestInit): Promise<Blob> {
        const { response, logObject } = await this.downloadBatchSearchReportRaw(requestParameters, initOverrides);
        const value = await response.value();
        logObject.populateResponseBody(value);
        this.createLogEntry(logObject);
        return value;
    }

    /**
     * This endpoint returns detailed information for a specific batch search using the provided ID. It is useful for tracking the status and progress of a previously initiated batch search operation.
     * Returns the batch search details using ID.
     */
    async getBatchSearchDetailRaw(requestParameters: GetBatchSearchDetailInterface, initOverrides?: RequestInit): Promise<{ response: runtime.ApiResponse<BatchSearch>, logObject: LogObject }> {
        requestParameters.avalaraVersion = requestParameters.avalaraVersion || '1.4';
        if (requestParameters.avalaraVersion === null || requestParameters.avalaraVersion === undefined) {
            throw new runtime.RequiredError('avalaraVersion','Required parameter requestParameters.avalaraVersion was null or undefined when calling getBatchSearchDetail.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getBatchSearchDetail.');
        }

        const queryParameters: any = {};
        const requiredScopes = "";
        const authNames: string[] = ['http'];
        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xAvalaraClient !== undefined && requestParameters.xAvalaraClient !== null) {
            headerParameters['X-Avalara-Client'] = String(requestParameters.xAvalaraClient);
        }

        if (requestParameters.xCorrelationID !== undefined && requestParameters.xCorrelationID !== null) {
            headerParameters['X-Correlation-ID'] = String(requestParameters.xCorrelationID);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const { response, logObject } = await this.request({
            path: `/einvoicing/trading-partners/batch-searches/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides, requiredScopes, false, runtime.AvalaraMicroservice.EInvoicing);
        logObject.populateResponseInfo(response);
        return { response: new runtime.JSONApiResponse(response, (jsonValue) => BatchSearchFromJSON(jsonValue)), logObject };
    }

    /**
     * This endpoint returns detailed information for a specific batch search using the provided ID. It is useful for tracking the status and progress of a previously initiated batch search operation.
     * Returns the batch search details using ID.
     */
    async getBatchSearchDetail(requestParameters: GetBatchSearchDetailInterface, initOverrides?: RequestInit): Promise<BatchSearch> {
        const { response, logObject } = await this.getBatchSearchDetailRaw(requestParameters, initOverrides);
        const value = await response.value();
        logObject.populateResponseBody(value);
        this.createLogEntry(logObject);
        return value;
    }

    /**
     * This endpoint retrieves a list of all batch search operations that have been previously submitted. It returns details such as the batch search ID, status, creation date, and associated metadata. It is useful for tracking the progress of a previously initiated batch search operations.
     * Lists all batch searches that were previously submitted.
     */
    async listBatchSearchesRaw(requestParameters: ListBatchSearchesInterface, initOverrides?: RequestInit): Promise<{ response: runtime.ApiResponse<BatchSearchListResponse>, logObject: LogObject }> {
        requestParameters.avalaraVersion = requestParameters.avalaraVersion || '1.4';
        if (requestParameters.avalaraVersion === null || requestParameters.avalaraVersion === undefined) {
            throw new runtime.RequiredError('avalaraVersion','Required parameter requestParameters.avalaraVersion was null or undefined when calling listBatchSearches.');
        }

        const queryParameters: any = {};
        const requiredScopes = "";
        const authNames: string[] = ['http'];
        if (requestParameters.$filter !== undefined) {
            queryParameters['$filter'] = requestParameters.$filter;
        }

        if (requestParameters.count !== undefined) {
            queryParameters['count'] = requestParameters.count;
        }

        if (requestParameters.$top !== undefined) {
            queryParameters['$top'] = requestParameters.$top;
        }

        if (requestParameters.$skip !== undefined) {
            queryParameters['$skip'] = requestParameters.$skip;
        }

        if (requestParameters.$orderBy !== undefined) {
            queryParameters['$orderBy'] = requestParameters.$orderBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xAvalaraClient !== undefined && requestParameters.xAvalaraClient !== null) {
            headerParameters['X-Avalara-Client'] = String(requestParameters.xAvalaraClient);
        }

        if (requestParameters.xCorrelationID !== undefined && requestParameters.xCorrelationID !== null) {
            headerParameters['X-Correlation-ID'] = String(requestParameters.xCorrelationID);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const { response, logObject } = await this.request({
            path: `/einvoicing/trading-partners/batch-searches`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides, requiredScopes, false, runtime.AvalaraMicroservice.EInvoicing);
        logObject.populateResponseInfo(response);
        return { response: new runtime.JSONApiResponse(response, (jsonValue) => BatchSearchListResponseFromJSON(jsonValue)), logObject };
    }

    /**
     * This endpoint retrieves a list of all batch search operations that have been previously submitted. It returns details such as the batch search ID, status, creation date, and associated metadata. It is useful for tracking the progress of a previously initiated batch search operations.
     * Lists all batch searches that were previously submitted.
     */
    async listBatchSearches(requestParameters: ListBatchSearchesInterface, initOverrides?: RequestInit): Promise<BatchSearchListResponse> {
        const { response, logObject } = await this.listBatchSearchesRaw(requestParameters, initOverrides);
        const value = await response.value();
        logObject.populateResponseBody(value);
        this.createLogEntry(logObject);
        return value;
    }

    /**
     * This endpoint retrieves a list of trading partners that match the specified search criteria. It supports filtering, search text, and other relevant query parameters to narrow down the results.
     * Returns a list of participants matching the input query.
     */
    async searchParticipantsRaw(requestParameters: SearchParticipantsInterface, initOverrides?: RequestInit): Promise<{ response: runtime.ApiResponse<SearchParticipants200Response>, logObject: LogObject }> {
        requestParameters.avalaraVersion = requestParameters.avalaraVersion || '1.4';
        if (requestParameters.avalaraVersion === null || requestParameters.avalaraVersion === undefined) {
            throw new runtime.RequiredError('avalaraVersion','Required parameter requestParameters.avalaraVersion was null or undefined when calling searchParticipants.');
        }

        if (requestParameters.$search === null || requestParameters.$search === undefined) {
            throw new runtime.RequiredError('$search','Required parameter requestParameters.$search was null or undefined when calling searchParticipants.');
        }

        const queryParameters: any = {};
        const requiredScopes = "";
        const authNames: string[] = ['http'];
        if (requestParameters.count !== undefined) {
            queryParameters['count'] = requestParameters.count;
        }

        if (requestParameters.$search !== undefined) {
            queryParameters['$search'] = requestParameters.$search;
        }

        if (requestParameters.$filter !== undefined) {
            queryParameters['$filter'] = requestParameters.$filter;
        }

        if (requestParameters.$top !== undefined) {
            queryParameters['$top'] = requestParameters.$top;
        }

        if (requestParameters.$skip !== undefined) {
            queryParameters['$skip'] = requestParameters.$skip;
        }

        if (requestParameters.$orderBy !== undefined) {
            queryParameters['$orderBy'] = requestParameters.$orderBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xAvalaraClient !== undefined && requestParameters.xAvalaraClient !== null) {
            headerParameters['X-Avalara-Client'] = String(requestParameters.xAvalaraClient);
        }

        if (requestParameters.xCorrelationID !== undefined && requestParameters.xCorrelationID !== null) {
            headerParameters['X-Correlation-ID'] = String(requestParameters.xCorrelationID);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const { response, logObject } = await this.request({
            path: `/einvoicing/trading-partners`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides, requiredScopes, false, runtime.AvalaraMicroservice.EInvoicing);
        logObject.populateResponseInfo(response);
        return { response: new runtime.JSONApiResponse(response, (jsonValue) => SearchParticipants200ResponseFromJSON(jsonValue)), logObject };
    }

    /**
     * This endpoint retrieves a list of trading partners that match the specified search criteria. It supports filtering, search text, and other relevant query parameters to narrow down the results.
     * Returns a list of participants matching the input query.
     */
    async searchParticipants(requestParameters: SearchParticipantsInterface, initOverrides?: RequestInit): Promise<SearchParticipants200Response> {
        const { response, logObject } = await this.searchParticipantsRaw(requestParameters, initOverrides);
        const value = await response.value();
        logObject.populateResponseBody(value);
        this.createLogEntry(logObject);
        return value;
    }

    /**
     * This endpoint updates the details of an existing trading partner specified by the provided ID. It performs a full update, and the request body must include all required fields.
     * Updates a trading partner using ID.
     */
    async updateTradingPartnerRaw(requestParameters: UpdateTradingPartnerInterface, initOverrides?: RequestInit): Promise<{ response: runtime.ApiResponse<UpdateTradingPartner200Response>, logObject: LogObject }> {
        requestParameters.avalaraVersion = requestParameters.avalaraVersion || '1.4';
        if (requestParameters.avalaraVersion === null || requestParameters.avalaraVersion === undefined) {
            throw new runtime.RequiredError('avalaraVersion','Required parameter requestParameters.avalaraVersion was null or undefined when calling updateTradingPartner.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateTradingPartner.');
        }

        if (requestParameters.tradingPartner === null || requestParameters.tradingPartner === undefined) {
            throw new runtime.RequiredError('tradingPartner','Required parameter requestParameters.tradingPartner was null or undefined when calling updateTradingPartner.');
        }

        const queryParameters: any = {};
        const requiredScopes = "";
        const authNames: string[] = ['http'];
        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xAvalaraClient !== undefined && requestParameters.xAvalaraClient !== null) {
            headerParameters['X-Avalara-Client'] = String(requestParameters.xAvalaraClient);
        }

        if (requestParameters.xCorrelationID !== undefined && requestParameters.xCorrelationID !== null) {
            headerParameters['X-Correlation-ID'] = String(requestParameters.xCorrelationID);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const { response, logObject } = await this.request({
            path: `/einvoicing/trading-partners/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: TradingPartnerToJSON(requestParameters.tradingPartner),
        }, initOverrides, requiredScopes, false, runtime.AvalaraMicroservice.EInvoicing);
        logObject.populateResponseInfo(response);
        return { response: new runtime.JSONApiResponse(response, (jsonValue) => UpdateTradingPartner200ResponseFromJSON(jsonValue)), logObject };
    }

    /**
     * This endpoint updates the details of an existing trading partner specified by the provided ID. It performs a full update, and the request body must include all required fields.
     * Updates a trading partner using ID.
     */
    async updateTradingPartner(requestParameters: UpdateTradingPartnerInterface, initOverrides?: RequestInit): Promise<UpdateTradingPartner200Response> {
        const { response, logObject } = await this.updateTradingPartnerRaw(requestParameters, initOverrides);
        const value = await response.value();
        logObject.populateResponseBody(value);
        this.createLogEntry(logObject);
        return value;
    }

}
